{
  "version": 3,
  "sources": ["lru.js"],
  "sourcesContent": ["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n!function(g,f){\n  if (typeof exports == 'object' && typeof module != \"undefined\") {\n    f(exports)\n  } else if (typeof define == 'function' && define.amd) {\n    define([\"exports\"], f)\n  } else {\n    f((g = g || self)[\"lru_map\"] = (g[\"lru_map\"] || {}))\n  }\n}(this, function(exports) {\n\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n\n  class LRUMap {\n    constructor(limit, entries) {\n      if (typeof limit !== 'number') {\n        // called as (entries)\n        entries = limit;\n        limit = 0;\n      }\n\n      this.size = 0;\n      this.limit = limit;\n      this.oldest = this.newest = undefined;\n      this._keymap = new Map();\n\n      if (entries) {\n        this.assign(entries);\n        if (limit < 1) {\n          this.limit = this.size;\n        }\n      }\n    }\n\n    _markEntryAsUsed(entry) {\n      if (entry === this.newest) {\n        // Already the most recenlty used entry, so no need to update the list\n        return;\n      }\n      // HEAD--------------TAIL\n      //   <.older   .newer>\n      //  <--- add direction --\n      //   A  B  C  <D>  E\n      if (entry[NEWER]) {\n        if (entry === this.oldest) {\n          this.oldest = entry[NEWER];\n        }\n        entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n      }\n      if (entry[OLDER]) {\n        entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n      }\n      entry[NEWER] = undefined; // D --x\n      entry[OLDER] = this.newest; // D. --> E\n      if (this.newest) {\n        this.newest[NEWER] = entry; // E. <-- D\n      }\n      this.newest = entry;\n    }\n\n    assign(entries) {\n      let entry, limit = this.limit || Number.MAX_VALUE;\n      this._keymap.clear();\n      let it = entries[Symbol.iterator]();\n      for (let itv = it.next(); !itv.done; itv = it.next()) {\n        let e = new Entry(itv.value[0], itv.value[1]);\n        this._keymap.set(e.key, e);\n        if (!entry) {\n          this.oldest = e;\n        } else {\n          entry[NEWER] = e;\n          e[OLDER] = entry;\n        }\n        entry = e;\n        if (limit-- == 0) {\n          throw new Error('overflow');\n        }\n      }\n      this.newest = entry;\n      this.size = this._keymap.size;\n    }\n\n    get(key) {\n      // First, find our cache entry\n      var entry = this._keymap.get(key);\n      if (!entry) return; // Not cached. Sorry.\n      // As <key> was found in the cache, register it as being requested recently\n      this._markEntryAsUsed(entry);\n      return entry.value;\n    }\n\n    set(key, value) {\n      var entry = this._keymap.get(key);\n\n      if (entry) {\n        // update existing\n        entry.value = value;\n        this._markEntryAsUsed(entry);\n        return this;\n      }\n\n      // new entry\n      this._keymap.set(key, (entry = new Entry(key, value)));\n\n      if (this.newest) {\n        // link previous tail to the new tail (entry)\n        this.newest[NEWER] = entry;\n        entry[OLDER] = this.newest;\n      } else {\n        // we're first in -- yay\n        this.oldest = entry;\n      }\n\n      // add new entry to the end of the linked list -- it's now the freshest entry.\n      this.newest = entry;\n      ++this.size;\n      if (this.size > this.limit) {\n        // we hit the limit -- remove the head\n        this.shift();\n      }\n\n      return this;\n    }\n\n    shift() {\n      // todo: handle special case when limit == 1\n      var entry = this.oldest;\n      if (entry) {\n        if (this.oldest[NEWER]) {\n          // advance the list\n          this.oldest = this.oldest[NEWER];\n          this.oldest[OLDER] = undefined;\n        } else {\n          // the cache is exhausted\n          this.oldest = undefined;\n          this.newest = undefined;\n        }\n        // Remove last strong reference to <entry> and remove links from the purged\n        // entry being returned:\n        entry[NEWER] = entry[OLDER] = undefined;\n        this._keymap.delete(entry.key);\n        --this.size;\n        return [entry.key, entry.value];\n      }\n    }\n\n    // -------------------------------------------------------------------------------------\n    // Following code (until end of class definition) is optional and can be removed without\n    // breaking the core functionality.\n\n    find(key) {\n      let e = this._keymap.get(key);\n      return e ? e.value : undefined;\n    }\n\n    has(key) {\n      return this._keymap.has(key);\n    }\n\n    delete(key) {\n      var entry = this._keymap.get(key);\n      if (!entry) return;\n      this._keymap.delete(entry.key);\n      if (entry[NEWER] && entry[OLDER]) {\n        // relink the older entry with the newer entry\n        entry[OLDER][NEWER] = entry[NEWER];\n        entry[NEWER][OLDER] = entry[OLDER];\n      } else if (entry[NEWER]) {\n        // remove the link to us\n        entry[NEWER][OLDER] = undefined;\n        // link the newer entry to head\n        this.oldest = entry[NEWER];\n      } else if (entry[OLDER]) {\n        // remove the link to us\n        entry[OLDER][NEWER] = undefined;\n        // link the newer entry to head\n        this.newest = entry[OLDER];\n      } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n        this.oldest = this.newest = undefined;\n      }\n\n      this.size--;\n      return entry.value;\n    }\n\n    clear() {\n      // Not clearing links should be safe, as we don't expose live links to user\n      this.oldest = this.newest = undefined;\n      this.size = 0;\n      this._keymap.clear();\n    }\n\n    keys() {\n      return new KeyIterator(this.oldest);\n    }\n\n    values() {\n      return new ValueIterator(this.oldest);\n    }\n\n    entries() {\n      return this;\n    }\n\n    [Symbol.iterator]() {\n      return new EntryIterator(this.oldest);\n    }\n\n    forEach(fun, thisObj) {\n      if (typeof thisObj !== 'object') {\n        thisObj = this;\n      }\n      let entry = this.oldest;\n      while (entry) {\n        fun.call(thisObj, entry.value, entry.key, this);\n        entry = entry[NEWER];\n      }\n    }\n\n    forEachWithBreak(fun) {\n      let entry = this.oldest;\n      let removedElements = 0;\n      while (entry) {\n        if (!fun.call(this, entry.value, entry.key, this)) {\n          break;\n        }\n        entry = this.oldest;\n        removedElements++;\n      }\n      return removedElements;\n    }\n\n    /** Returns a JSON (array) representation */\n    toJSON() {\n      var s = new Array(this.size), i = 0, entry = this.oldest;\n      while (entry) {\n        s[i++] = { key: entry.key, value: entry.value };\n        entry = entry[NEWER];\n      }\n      return s;\n    }\n\n    /** Returns a String representation */\n    toString() {\n      var s = '', entry = this.oldest;\n      while (entry) {\n        s += String(entry.key)+':'+entry.value;\n        entry = entry[NEWER];\n        if (entry) {\n          s += ' < ';\n        }\n      }\n      return s;\n    }\n  }\n\n  exports.LRUMap = LRUMap\n\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n\n\n  function EntryIterator(oldestEntry) { this.entry = oldestEntry; }\n  EntryIterator.prototype[Symbol.iterator] = function() { return this; }\n  EntryIterator.prototype.next = function() {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return { done: false, value: [ent.key, ent.value] };\n    } else {\n      return { done: true, value: undefined };\n    }\n  };\n\n\n  function KeyIterator(oldestEntry) { this.entry = oldestEntry; }\n  KeyIterator.prototype[Symbol.iterator] = function() { return this; }\n  KeyIterator.prototype.next = function() {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return { done: false, value: ent.key };\n    } else {\n      return { done: true, value: undefined };\n    }\n  };\n\n  function ValueIterator(oldestEntry) { this.entry = oldestEntry; }\n  ValueIterator.prototype[Symbol.iterator] = function() { return this; }\n  ValueIterator.prototype.next = function() {\n    let ent = this.entry;\n    if (ent) {\n      this.entry = ent[NEWER];\n      return { done: false, value: ent.value };\n    } else {\n      return { done: true, value: undefined };\n    }\n  };\n\n});\n"],
  "mappings": "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",
  "names": []
}
